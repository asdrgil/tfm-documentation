%---------------------------------------------------------------------
%
%                          Capítulo 1 - Estado del arte
%
%---------------------------------------------------------------------

\chapter{Arquitectura de datos}

\begin{resumen}

En esta sección, se va a explicar la arquitectura de datos de la solución implementada así como la justificación de la misma frente a otras alternativas que se presentarán en el capítulo. La memoria está estructurada siguendo el modelo clásico cliente-servidor en la que el ordenador realiza la función de servidor y el móvil de cliente. 
\end{resumen}


%-------------------------------------------------------------------
\section{Bases de datos}
\paragraph{}
En la solución implementada, era crucial disponer de un servidor para que los profesionales que tratasen directamente con el paciente pudiesen supervisar los registros del mismo sin tener que esperar a la visita física del paciente para analizar los datos registrados por el dispositivo IOT. El primer dilema que se plantea es si almacenar los datos generados en un servidor externo como Azure, Amazon Web Services, Google Cloud o Alibaba Cloud o por contra almacenarlos en un servidor propio. Que dicho almacenamiento sea en un servidor externo tiene como principal ventaja la comodidad del programador, pues estos servidores externos suelen añadir servicios adicionales como la inclusión de bases de datos de distintos tipos ya configuradas así como distintos tipos de mecanismos de seguridad frente a ataques externos. La principal desventaja de estas soluciones es la falta de flexibilidad frente a la implementación en servidores propios así como el hecho de que en un servidor propio los únicos costes tecnológicos son la luz consumida por el dispositivo de almacenamiento (como puede ser un ordenador) y el propio dispositivo. Tras sopesar ambas opciones, se decide utilizar un servidor propio, pues la desventaja del mayor tiempo de desarrollo necesario para la puesta en marcha se ve minimizada por la existencia de numerosos ejemplos de servidores bastante similares al que se requiere para este trabajo.

\paragraph{}
En lo que respecta al tipo de base de datos a utilizar en el servidor, existe la posibilidad de utilizar bases de datos relacionales y no relacionales. A continuación se va a describir en qué consiste cada uno de estos tipos de base de datos con el fin de justificar después la elección del tipo de base de datos utilizada.

\subsection{Bases de datos relaciones}
\paragraph{}
Una base de datos completamente relacional es utilizada generalmente para almacenar lo que se denominan datos \textit{clásicos} en la que al realizar una consulta sobre los mismos no existe ninguna incertidumbre, se obtienen la tupla de valores en la forma exacta en la que se ha solicitado \citep{jimenez2016implementacion}. Estas bases de datos a su vez deben de tener definidas al menos las reglas de inserción, actualización y eliminación de datos \citep{codd1979extending}.

\paragraph{}
Estas bases de datos tienen como principales desventajas la menor escalabilidad respecto a bases de datos no relacionales y la dificultad para lidiar con datos que no tengan una estructura previamente conocida y/o fuertemente tipificada. Por otro lado, debido al largo tiempo que estas bases de datos llevan siendo utilizadas, existe una gran comunidad de desarrolladores detrás de lenguajes como SQL lo que facilita su implementación.

\subsection{Bases de datos no relacionales}
\paragraph{}
Las bases de datos no relacionales se basan en una mayor flexibilidad a la hora de almacenar datos con atributos y contenido dispar, pudiendo añadir nuevos atributos sin tener que modificar el contenido de otros registros. Estas bases de datos suelen facilitar la escalabilidad horizontal así como la posibilidad de replicar y distribuir los datos entre los distintos servidores, al poderse particionar los datos por patrones.

\paragraph{}
Entre las bases de datos no relacionales o no-sql podemos encontrar los siguientes tipos \citep{aws-nosql}:

\begin{itemize}
\item Clave-valor: son altamente divisibles y permiten un gran escalado horizontal. Algunos de sus casos de uso son los videojuegos, la tecnología publicitaria o IOT. Algunos ejemplos de estas bases de datos son Redis y Cassandra.
\item Documento: es un modelo que no se basa en filas y columnas desnormalizadas, sino que los datos se presentan en formatos como JSON. Algunos ejemplos de estas bases de datos son MongoDB y CouchDB.
\item Gráficas: son principalmente usadas en aplicaciones que trabajan con conjuntos de datos fuertemente conectados, como es el caso de los datos relacionados con las redes sociales, motores de recomendaciones y gráficos de conocimiento. Entre este tipo de base de datos se encuentran Neo4j y OrientDB.
\end{itemize}

\subsection{Justificación de la base de datos elegida}
\paragraph{}
Poniendo en la balanza los elementos mencionados en las dos subsecciones previas, se ha considerado que las bases de datos no relacionales son las que mejor se adaptan al uso que se va a hacer del servidor. El motivo principal es el hecho de que los datos no tienen necesariamente que estar fuertemente estructurados; puede suceder que la pulsera de un paciente en algún momento no guarde un dato concreto por errores de hardware de la misma o que utilice una pulsera que no disponga de todos los indicadores inicialmente previstos, lo que en el caso de las bases de datos no relacionales se puede gestionar con facilidad sin necesidad de guardar columnas con el valor nulo en cada sensorización.

\paragraph{}
Otros factores relevantes a la hora de elegir un lenguaje para una base de datos son los siguientes:
\begin{enumerate}
\item Que el lenguaje utilizado sea de software libre para que así no haya limitaciones en el conocimiento que se puede tener sobre el mismo.
\item Fácil interacción con dicha base de datos en el lenguaje en el que se vaya a programar el cliente y/o el servidor que se pretenda que tenga algún tipo de acceso directo a la misma. Esta facilidad es subjetiva y no es el propósito de este trabajo buscar métodos que estandaricen dicha medición entre distintos programadores. Por contra, como el desarrollador de la solución es la persona que escribe esta misma memoria, será su criterio intencionadamente subjetivo el que prevalezca tanto en este como en el siguiente factor.
\item Fácil interacción en el medio tecnológico en el que se vaya a interactuar con la base de datos (un ordenador, un Arduino, un móvil etc).
\item Una comunidad de desarrolladores que facilite la resolución de dudas. Esto puede verse reflejado principalmente en los índices de popularidad de dichos lenguajes en los foros de programación como Stackoverflow.
\item Versiones estables de dicho lenguaje de la base de datos para el fin que se le quiera dar.
\item La experiencia previa del desarrollador con dicho lenguaje, que puede hacer que disminuya el tiempo necesario de programación disminuyendo por tanto el tiempo necesario para el desarrollo de la solución.
\end{enumerate}

\paragraph{}
En nuestro caso particular, esto implica la necesidad de un lenguaje de fácil interacción en Android y Python. En el caso de Android, esta interacción debe ser tanto a nivel de cliente (conexión con el servicio web para sincronizar los datos) como de servidor (servidor local en el que guardar los datos antes de ser sincronizados).


\paragraph{}
Añadiendo estos nuevos factores a los ya mencionados, los lenguajes de bases de datos que se considera que podrían llegar a cumplir esta función son Redis, Cassandra, MongoDB y Couchbase, al ser todos ellos de software libre (punto 1), haya una fácil interaccion en la parte del servidor ejecutado en un ordenador y cuyas interacciones están definidas en Python (punto 2 y 3) y todos ellos llevan por lo menos siete años siendo públicos.

\paragraph{}
Entre estos lenguajes, Redis y Cassandra son descartados por una mezcla entre el punto 3 y el punto 4:  a pesar de encontrarse ambas entre las quince bases de datos más utilizadas según la encuesta de Stackoverflow de 2018 \citep{so-db}, ni siquiera en la propia documentación de las páginas oficiales de estos lenguajes se explica la manera en la que se producirían estas interacciones desde Android.

\paragraph{}
En el caso de Couchbase y MongoDB, ambos cuentan con documentación para Android en sus respectivas páginas oficiales así como proyectos de ejemplo en los que queda bastante claro la manera de interactuar con las bases de datos. En el caso de MongoDB, se cuenta con experiencia previa con dicho lenguaje (punto 6), mientras que a pesar de no haber usado previamente Couchbase, esta cuenta con un sistema de consultas de datos llamado N1QL cuya sintaxis es bastante más intuitiva que la de MongoDB. A su vez, ambas cuentan con contenedores Docker ya configurados así como tutoriales que facilitan su puesta en marcha y modificación. Teniendo todo esto en cuenta, realmente se podría haber elegido cualquiera de estas dos soluciones para este proyecto, decantándose finalmente por utilizar Couchbase debido a que se considera que N1QL facilita tener un código limpio y mejor estructurado.
